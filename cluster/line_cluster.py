import numpy as np
import numpy.linalg as LA
import cv2, math
from enum import Enum
from draw.colors import COLORS, Rainbow
from draw.draw_lines import drawLines
from draw.draw_points import drawPoints
from draw.draw_uvlines import drawUVLines
from collections import namedtuple
import geometry as geo
from geometry.rectangle import Rectangle
from cluster.cluster_bin import ClusterBin
import matplotlib.pyplot as plt
from file_processor import util

DRAW_STYLE = namedtuple('DRAW_STYLE', ['dots', 'circles', 'lines', 'circle_lines'])
DRAW_STYLE.dots = 1
DRAW_STYLE.circles = 2
DRAW_STYLE.lines = 3
DRAW_STYLE.circle_lines = 4

class LineCluster:
  def __init__(self, points, sampleSize, avgThresh, minThresh, 
    img = None, path = None):
    """LineCluster for binning points by line when points are sorted.

    Args:
      points (array_like): ndarray (n, 1, 2)
      sampleSize (int): Number of points to sample before determining to bin
      avgThresh (float): if avg(sample) > avgThresh then make bin
      minThresh (float): end bin and fist point in sample above minThresh
      concurrentThresh (float): range(-1, 1) for are lines concurrent

    Attributes:
      points (array_like): ndarray (n, 1, 2)
      bins (list of ClusterBin): Bins
    
    Returns:
      LineCluster: Object for making bins of points
    """
    self.points = points
    self.bins = []
    self.img = img

    start = 0
    
    # Start at 3 so there is a sample to fitline
    i = 3
    while i < self.points.shape[0]:
      thisBin = ClusterBin(start, i + 1)
      cbin = thisBin.getFrom(self.points)

      sampleBin = ClusterBin(i, i + sampleSize)
      sample = sampleBin.getFrom(self.points)
      
      wall = self.fitLine(cbin)
      # wall = cv2.fitLine(cbin, cv2.NORM_L2, 0, 0.01, 0.01)
      sampleDist = np.zeros((sampleSize))
      
      for n in range(sampleSize):
        sampleDist[n] = geo.line.distFrom(wall, sample[n])
      avg_dist = np.average(sampleDist)

      if avg_dist > avgThresh:
        end = i + np.argmax(sampleDist > minThresh)
        b = ClusterBin(start, end)
        self.bins.append(b)
        start = end - 1
        i = start
      i = i + 1

    i = 0
    while i < len(self.bins):
      if self.isBinsSimilar(i, i + 1):
        self.merge(i, i + 1)
      else:
        i += 1
    
    if img is not None:
      temp = self.img.copy()
      temp = util.factor(img, 0.15)
      temp2 = temp.copy()
      r = Rainbow(
        1.0, 1.0, 1.0, 
        0, np.radians(90), np.radians(180),
        135, 135, 135,
        120, 120, 120, 
        np.radians(30))
      for n in range(len(self.bins)):
        cbin = self.unpack(n)
        line = self.getLine(n)
        geo.line.drawLineSegment(temp, line, COLORS.red, 2)
        # cv2.circle(temp, tuple(line[0, 0:2]), 3, COLORS.red)
        # cv2.circle(temp, tuple(line[0, 2:4]), 3, COLORS.red)
        uvline = self.fitLine(cbin)
        # uvline = cv2.fitLine(cbin, cv2.NORM_L2, 0, 0.01, 0.01).T
        # geo.line.drawUnitVector(temp, uvline, r.next())
        # geo.line.drawUnitVector(temp, uvline, COLORS.red)
      
      uvlines = self.toUVLines(16)
      corners = geo.line.asIntersections(uvlines)
      geo.point.drawPoints(temp2, corners)

      temp = np.vstack((temp, temp2))

      if path is not None:
        temp = util.scale(temp, 3)
        cv2.imwrite(path, temp)
    
  def merge(self, b1, b2):
    """Merge two bins together and delete the second bin

    Args:
      b1 (int): Index of bin 1
      b2 (int): Index of bin 2
    """
    if self.img is not None:
      temp = self.img.copy()
      temp = util.factor(temp, 0.15)

      cbin = self.unpack(b1)
      uvline = self.fitLine(cbin)
      geo.point.drawPoints(temp, cbin, color=COLORS.rainbow.next(0.5), thickness=0)
      geo.line.drawUnitVector(temp, uvline, COLORS.rainbow.next())

      COLORS.rainbow.skip()

      cbin = self.unpack(b2)
      uvline = self.fitLine(cbin)
      geo.point.drawPoints(temp, cbin, color=COLORS.rainbow.next(0.5), thickness=0)
      geo.line.drawUnitVector(temp, uvline, COLORS.rainbow.next())

      # util.show(temp, time = 10)

    b1 = b1 % len(self.bins)
    b2 = b2 % len(self.bins)
    self.bins[b1] = self.bins[b1].add(self.bins[b2])
    del self.bins[b2]

  def unpack(self, index):
    """Returns the points in bin at index

    Args:
      index (int): The index of the bin to unpack

    Returns:
      array_like: Points in bin
    """
    index = index % len(self.bins)
    return self.bins[index].getFrom(self.points)

  def toUVLines(self, numSteps = 4):
    """Return a subset of bins as UVLines

    Subset determined by thresh limiting small UVLines generated by noise.

    Args:
      thresh (float): The filter for line segments too short.

    Returns:
      UVLines: A List of UVLines
    """

    lines = np.empty((len(self.bins), 1, 4), np.float32)
    step = np.pi / numSteps

    for n, b in enumerate(self.bins):
      cbin = b.getFrom(self.points)
      fitline = self.fitLine(cbin)
      # fitline = cv2.fitLine(cbin, cv2.NORM_L2, 0, 0.01, 0.01)
      # fitline = fitline.T

      # TODO: Snap
      # theta = np.arctan2(fitline[0, 1], fitline[0, 0])
      # theta = round(theta * numSteps) * step
      # fitline[0, 0] = math.cos(theta)
      # fitline[0, 1] = math.sin(theta)

      lines[n] = fitline

    return lines

  def fitLine(self, cbin):
    uv = cv2.fitLine(cbin, cv2.NORM_L2, 0, 0.01, 0.01).T
    vx, vy = uv[0, 0:2]

    direction = cbin[-1] - cbin[0]
    direction = direction / LA.norm(direction)
    dx, dy = direction[0]

    if (dx >= 0) != (vx >= 0):
      vx = vx * -1.0
    
    if (dy >= 0) != (vy >= 0):
      vy = vy * -1.0

    uv[0, 0] = vx
    uv[0, 1] = vy

    return uv

  def isBinsSimilar(self, b1, b2, minLineLength = 8, concurrentThresh = 0.5):
    """Determin if two bins should be one

    Args:
      b1 (ClusterBin): Bin 1
      b2 (ClusterBin): Bin 2
      minLineLength (int): Smallest possible line
    """
    bin1 = self.unpack(b1)
    bin2 = self.unpack(b2)

    uvLine1 = self.fitLine(bin1)
    uvLine2 = self.fitLine(bin2)

    isColinear = geo.line.isColinear(uvLine1, uvLine2, concurrentThresh)

    if isColinear:
      print('Lines are colinear (%s . %s == %s)' % (uvLine1[0, 0:2], uvLine2[0, 0:2], abs(np.dot(uvLine1[0, 0:2], uvLine2[0, 0:2]))))

    # wall = self.getLine(b2)
    # isTooSmall = geo.line.length(wall) < minLineLength
    bounds = cv2.boundingRect(bin2)
    pos, size, rot = cv2.minAreaRect(bin2)
    rectSize = max(size[0], 1) * max(size[1], 1)
    isTooSmall = rectSize < minLineLength
    print(rectSize)

    if isTooSmall:
      print('Second line is too small')
      if self.img is not None:
        temp = self.img.copy()
        temp = util.factor(temp, 0.15)

        x,y,w,h = cv2.boundingRect(bin2)
        cv2.rectangle(temp,(x,y),(x+w,y+h),COLORS.rainbow.next())

        geo.point.drawPoints(temp, bin2, color=COLORS.rainbow.next(0.5), thickness=0)

        # util.show(temp, time=500, text='Length=%s' % rectSize)


    # is edge case code:
    bounds = cv2.boundingRect(bin2)
    bounds = np.array([bounds])
    # (x, y, w, h) => (left, top, right, bottom)
    bounds[0, 2:4] = bounds[0, 2:4] + bounds[0, 0:2]
    bounds = Rectangle.expand(bounds, 5)

    return isColinear or isTooSmall

  def getLine(self, index):
    """Returns the line segment defined by a bin

    Args:
      index (int): index of bin

    Returns:
      array_list: ndarray(1, 4) line-segment
    """
    b1 = (index - 1) % len(self.bins)
    b2 = index % len(self.bins)
    b3 = (index + 1) % len(self.bins)

    uv1 = self.fitLine(self.unpack(b1))
    uv2 = self.fitLine(self.unpack(b2))
    uv3 = self.fitLine(self.unpack(b3))

    p1 = geo.line.intersection(uv1, uv2)
    p2 = geo.line.intersection(uv2, uv3)

    return np.hstack((p1, p2))